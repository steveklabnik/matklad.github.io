<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Generate All the Things</title>
  <meta name="description"
    content="In this post, we&#8217;ll look at one technique from property-based testing repertoire: full coverage / exhaustive testing.Specifically, we will learn how to...">
  <link rel="canonical" href="https://matklad.github.io//2021/11/07/generate-all-the-things.html">
  <link rel="alternate" type="application/rss+xml" title="matklad" href="https://matklad.github.io//feed.xml">

  <style>
    @font-face {
      font-family: 'JetBrains Mono';
      src: url('/css/JetBrainsMono-Regular.woff2') format('woff2');
    }

    @font-face {
      font-family: 'JetBrains Mono';
      src: url('/css/JetBrainsMono-Bold.woff2') format('woff2');
      ;
      font-weight: bold;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      margin-block-start: 0;
      margin-block-end: 0;
    }

    h1,
    h2,
    h3 {
      font-weight: 300;
    }

    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }

    main {
      display: flex;
      flex-direction: column;
      width: 100%;
      max-width: 80ch;
      padding-left: 2ch;
      padding-right: 2ch;
    }

    .site-header {
      width: 100%;
      max-width: 80ch;
      margin-bottom: 1.5rem;
    }

    .site-header>nav {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: baseline;
    }

    .site-header .-title {
      flex-grow: 2;
    }

    .site-footer {
      display: flex;
      justify-content: center;
      align-items: baseline;
      width: 100%;
      max-width: 80ch;
      margin-top: 1rem;
      height: 2rem;
      padding-left: 1ch;
      padding-right: 1ch;
    }
  </style>
  <link rel="stylesheet" href=" /css/adoc.css">
  <link rel="stylesheet" href=" /css/rouge-github.css">
  <link rel="stylesheet" href=" /css/main.css">
  <link rel="stylesheet"
    href="https://fonts.googleapis.com/css?family=EB+Garamond:400,400italic,700,700italic%7COpen+Sans:300">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
</head>

<body>
  <header class="site-header">
    <nav>
      <a class="-title" href="/">matklad</a>
      
      
      <a href="/about/">About</a>
      
      
      
      
      
      <a href="/resume/">Resume</a>
      
      
      
      
      
      
      
      
      
      
    </nav>
  </header>

  <main>
    <article>
  <h1>Generate All the Things</h1>
  <div class="post-meta sect1">Nov 7, 2021</div>
  <div class="paragraph">
<p>In this post, we&#8217;ll look at one technique from property-based testing repertoire: full coverage / exhaustive testing.
Specifically, we will learn how to conveniently enumerate any kind of combinatorial object without using recursion.</p>
</div>
<div class="paragraph">
<p>To start, let&#8217;s assume we have some algorithmic problem to solve.
For example, we want to sort an array of numbers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">sort</span><span class="p">(</span><span class="n">xs</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">u32</span><span class="p">])</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>To test that the <code>sort</code> function works, we can write a bunch of example-based test cases.
This approach has two flaws:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Generating examples by hand is time consuming.</p>
</li>
<li>
<p>It might be hard to come up with interesting examples&#8201;&#8212;&#8201;any edge cases we&#8217;ve thought about is probably already handled in the code.
We want to find cases which we didn&#8217;t think of before.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A better approach is randomized testing: just generate a random array and check that it is sorted:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">naive_randomized_testing</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">rng</span> <span class="o">=</span> <span class="nn">rand</span><span class="p">::</span><span class="nf">thread_rng</span><span class="p">();</span>
  <span class="k">for</span> <span class="mi">_</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">100_000</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">n</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="n">rng</span><span class="nf">.gen_range</span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">1_000</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">xs</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span> <span class="o">=</span>
      <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">repeat_with</span><span class="p">(||</span> <span class="n">rng</span><span class="nf">.gen</span><span class="p">())</span><span class="nf">.take</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="nf">.collect</span><span class="p">();</span>

    <span class="nf">sort</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">xs</span><span class="p">);</span>

    <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">1</span><span class="o">..</span><span class="n">xs</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">assert</span><span class="o">!</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, we generated one hundred thousand completely random test cases!</p>
</div>
<div class="paragraph">
<p>Sadly, the result might actually be <em>worse</em> than a small set of hand-picked examples.
The problem here is that, if you pick an array completely at random (sample uniformly), it will be a rather ordinary array.
In particular, given that the elements are arbitrary <code>u32</code> numbers, it&#8217;s highly unlikely that we generate an array with at least some equal elements.
And when I write quick sort, I always have that nasty bug that it just loops infinitely when <em>all</em> elements are equal.</p>
</div>
<div class="paragraph">
<p>There are several fixes for the problem.
The simplest one is to just make the sampling space smaller:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">repeat_with</span><span class="p">(||</span> <span class="n">rng</span><span class="nf">.gen_rang</span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">10</span><span class="p">))</span><span class="nf">.take</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="nf">.collect</span><span class="p">();</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>If we generate not an arbitrary <code>u32</code>, but a number between 0 and 10, we&#8217;ll get some short arrays where all elements are equal.
Another trick is to use a property-based testing library, which comes with some strategies for generating interesting sequences predefined.
Yet another approach is to combine property-based testing and coverage guided fuzzing.
When checking a particular example, we will collect coverage information for this specific input.
Given a set of inputs with coverage info, we can apply targeted genetic algorithms to try to cover more of the code.
A particularly fruitful insight here is that we don&#8217;t have to invent a novel structure-aware fuzzer for this.
We can take an existing fuzzer which emits a sequence of bytes, and use those bytes as a sequence of random numbers to generate structured input.
Essentially, we say that the fuzzer <em>is</em> a random number generator.
That way, when the fuzzer flips bits in the raw bytes array, it applies local semantically valid transformations to the random data structure.</p>
</div>
<div class="paragraph">
<p>But this post isn&#8217;t about those techniques :)
Instead, it is about the idea of full coverage.
<em>Most</em> of the bugs involve small, tricky examples.
If a sorting routine breaks on some array with ten thousand elements it&#8217;s highly likely that there&#8217;s a much smaller array (a handful of elements), which exposes the same bug.
So what we can do is to just generate <em>every</em> array of length at most <code>n</code> with numbers up to <code>m</code> and exhaustively check them all:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
</pre></td><td class="code"><pre><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">exhaustive_testing</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">xs</span> <span class="n">in</span> <span class="nf">every_array</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">sort</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">xs</span><span class="p">);</span>

    <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">1</span><span class="o">..</span><span class="n">xs</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">assert</span><span class="o">!</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The problem here is that implementing <code>every_array</code> is tricky.
It is one of those puzzlers you know how to solve, but which are excruciatingly annoying  to implement for the umpteenth time:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">every_array</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">()];</span>
  <span class="p">}</span>

  <span class="k">let</span> <span class="k">mut</span> <span class="n">res</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
  <span class="k">for</span> <span class="n">xs</span> <span class="n">in</span> <span class="nf">every_array</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">x</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..=</span><span class="n">m</span> <span class="p">{</span>
      <span class="k">let</span> <span class="k">mut</span> <span class="n">ys</span> <span class="o">=</span> <span class="n">xs</span><span class="nf">.clone</span><span class="p">();</span>
      <span class="n">ys</span><span class="nf">.push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
      <span class="n">res</span><span class="nf">.push</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">res</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>What&#8217;s more, for algorithms you often need to generate permutations, combinations and subsets, and they all have similar simple but tricky recursive solutions.</p>
</div>
<div class="paragraph">
<p>Yesterday I needed to generate a sequence of up to <code>n</code> segments with integer coordinates up to <code>m</code>, which finally pushed me to realize that there&#8217;s a relatively simple way to exhaustively enumerate arbitrary combinatorial objects.
I don&#8217;t recall seeing it anywhere else, which is surprising, as the technique seems rather elegant.</p>
</div>
<hr>
<div class="paragraph">
<p>Let&#8217;s look again at how we generate a random array:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">let</span> <span class="n">l</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="n">rng</span><span class="nf">.gen_range</span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">l</span><span class="p">);</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">xs</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span> <span class="o">=</span>
  <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">repeat_with</span><span class="p">(||</span> <span class="n">rng</span><span class="nf">.gen</span><span class="p">(</span><span class="o">..</span><span class="n">m</span><span class="p">))</span><span class="nf">.take</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="nf">.collect</span><span class="p">();</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is definitely much more straightforward than the <code>every_array</code> function above, although it does sort-of the same thing.
The trick is to take this &#8220;generate <em>a random</em> thing&#8221; code and just make it generate <em>every</em> thing instead.
In the above code, we base decisions on random numbers.
Specifically, an input sequence of random numbers generates one element in the search space.
If we enumerate all sequences of random numbers, we then explore the whole space.</p>
</div>
<div class="paragraph">
<p>Essentially, we&#8217;ll rig the <code>rng</code> to not be random, but instead to emit all finite sequences of numbers.
By writing a single generator of such sequences, we gain an ability to enumerate arbitrary objects.
As we are interested in generating all &#8220;small&#8221; objects, we always pass an upper bound when asking for a &#8220;random&#8221; number.
We can use the bounds to enumerate only the sequences which fit under them.</p>
</div>
<div class="paragraph">
<p>So, the end result will look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
</pre></td><td class="code"><pre><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">for_every_array</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

  <span class="k">let</span> <span class="k">mut</span> <span class="n">g</span> <span class="o">=</span> <span class="nn">Gen</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
  <span class="k">while</span> <span class="o">!</span><span class="n">g</span><span class="nf">.done</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="n">g</span><span class="nf">.gen</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">xs</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="mi">_</span><span class="o">&gt;</span> <span class="o">=</span>
      <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">repeat_with</span><span class="p">(||</span> <span class="n">g</span><span class="nf">.gen</span><span class="p">(</span><span class="n">m</span><span class="p">))</span><span class="nf">.take</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="mi">_</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="c">// `xs` enumerates all arrays</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The implementation of <code>Gen</code> is relatively straightforward.
On each iteration, we will remember the sequence of numbers we generated together with bounds the user requested, something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre>value:  3 1 4 4
bound:  5 4 4 4
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>To advance to the next iteration, we will find the smallest sequence of values which is larger than the current one, but still satisfies all the bounds.
&#8220;Smallest&#8221; means that we&#8217;ll try to increment the rightmost number.
In the above example, the last two fours already match the bound, so we can&#8217;t increment them.
However, we <em>can</em> increment one to get <code>3 2 4 4</code>.
This isn&#8217;t the smallest sequence though, <code>3 2 0 0</code> would be smaller.
So, after incrementing the rightmost number we can increment, we zero the rest.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s the full implementation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">Gen</span> <span class="p">{</span>
  <span class="n">started</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
  <span class="n">v</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">u32</span><span class="p">,</span> <span class="nb">u32</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">p</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Gen</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Gen</span> <span class="p">{</span>
    <span class="n">Gen</span> <span class="p">{</span> <span class="n">started</span><span class="p">:</span> <span class="k">false</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span> <span class="n">p</span><span class="p">:</span> <span class="mi">0</span> <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">fn</span> <span class="nf">done</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="o">!</span><span class="k">self</span><span class="py">.started</span> <span class="p">{</span>
      <span class="k">self</span><span class="py">.started</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
      <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">i</span> <span class="nf">in</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="k">self</span><span class="py">.v</span><span class="nf">.len</span><span class="p">())</span><span class="nf">.rev</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">if</span> <span class="k">self</span><span class="py">.v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="na">.0</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="na">.1</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="na">.0</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">self</span><span class="py">.v</span><span class="nf">.truncate</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">self</span><span class="py">.p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">true</span>
  <span class="p">}</span>
  <span class="k">fn</span> <span class="nf">gen</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">bound</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">self</span><span class="py">.p</span> <span class="o">==</span> <span class="k">self</span><span class="py">.v</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">self</span><span class="py">.v</span><span class="nf">.push</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">self</span><span class="py">.p</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">self</span><span class="py">.v</span><span class="p">[</span><span class="k">self</span><span class="py">.p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="na">.1</span> <span class="o">=</span> <span class="n">bound</span><span class="p">;</span>
    <span class="k">self</span><span class="py">.v</span><span class="p">[</span><span class="k">self</span><span class="py">.p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="na">.0</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Some notes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>We need <code>start</code> field to track the first iteration, and to make <code>while !g.done()</code> syntax work.
It&#8217;s a bit more natural to remove <code>start</code> and use a <code>do { } while !g.done()</code> loop, but it&#8217;s not available in Rust.</p>
</li>
<li>
<p><code>v</code> stores <code>(value, bound)</code> pairs.</p>
</li>
<li>
<p><code>p</code> tracks the current position in the middle of the iteration.</p>
</li>
<li>
<p><code>v</code> is conceptually an infinite vector with finite number of non-zero elements.
So, when <code>p</code> gets past then end of <code>v</code>, we just materialize the implicit zero by pushing it onto <code>v</code>.</p>
</li>
<li>
<p>As we store zeros implicitly anyway, we can just truncate the vector in <code>done</code> instead of zeroing-out the elements after the incremented one.</p>
</li>
<li>
<p>Somewhat unusually, the bounds are treated inclusively.
This removes the panic when <code>bound</code> is zero, and allows to generate a full set of numbers via <code>gen(u32::MAX)</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s see how our <code>gen</code> fairs for generating random arrays of length at most <code>n</code>.
We&#8217;ll count how many distinct cases were covered:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">gen_arrays</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">expected_total</span> <span class="o">=</span>
    <span class="p">(</span><span class="mi">0</span><span class="o">..=</span><span class="n">n</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">l</span><span class="p">|</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.pow</span><span class="p">(</span><span class="n">l</span><span class="p">))</span><span class="py">.sum</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="k">let</span> <span class="k">mut</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">all</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

  <span class="k">let</span> <span class="k">mut</span> <span class="n">g</span> <span class="o">=</span> <span class="nn">Gen</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
  <span class="k">while</span> <span class="o">!</span><span class="n">g</span><span class="nf">.done</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="n">g</span><span class="nf">.gen</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">xs</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="mi">_</span><span class="o">&gt;</span> <span class="o">=</span>
      <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">repeat_with</span><span class="p">(||</span> <span class="n">g</span><span class="nf">.gen</span><span class="p">(</span><span class="n">m</span><span class="p">))</span><span class="nf">.take</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="mi">_</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="n">all</span><span class="nf">.insert</span><span class="p">(</span><span class="n">xs</span><span class="p">);</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="p">}</span>

  <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">all</span><span class="nf">.len</span><span class="p">(),</span> <span class="n">total</span><span class="p">);</span>
  <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">expected_total</span><span class="p">,</span> <span class="n">total</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This test passes.
That is, the <code>gen</code> approach for this case is both exhaustive (it generates all arrays) and efficient (each array is generated once).</p>
</div>
<div class="paragraph">
<p>As promised in the post&#8217;s title, let&#8217;s now generate <em>all</em> the things.</p>
</div>
<div class="paragraph">
<p>First case: there should be only one nothing (that&#8217;s the reason why we need <code>start</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
</pre></td><td class="code"><pre><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">gen_nothing</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">expected_total</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="k">let</span> <span class="k">mut</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">g</span> <span class="o">=</span> <span class="nn">Gen</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
  <span class="k">while</span> <span class="o">!</span><span class="n">g</span><span class="nf">.done</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">expected_total</span><span class="p">,</span> <span class="n">total</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Second case: we expect to see <code>n</code> numbers and <code>n*2</code> ordered pairs of numbers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">gen_number</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">expected_total</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

  <span class="k">let</span> <span class="k">mut</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">all</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">g</span> <span class="o">=</span> <span class="nn">Gen</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
  <span class="k">while</span> <span class="o">!</span><span class="n">g</span><span class="nf">.done</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="n">g</span><span class="nf">.gen</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

    <span class="n">all</span><span class="nf">.insert</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">expected_total</span><span class="p">,</span> <span class="n">total</span><span class="p">);</span>
  <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">expected_total</span><span class="p">,</span> <span class="n">all</span><span class="nf">.len</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">);</span>
<span class="p">}</span>

<span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">gen_number_pair</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">expected_total</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

  <span class="k">let</span> <span class="k">mut</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">all</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">g</span> <span class="o">=</span> <span class="nn">Gen</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
  <span class="k">while</span> <span class="o">!</span><span class="n">g</span><span class="nf">.done</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="n">g</span><span class="nf">.gen</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">g</span><span class="nf">.gen</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

    <span class="n">all</span><span class="nf">.insert</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">));</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">expected_total</span><span class="p">,</span> <span class="n">total</span><span class="p">);</span>
  <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">expected_total</span><span class="p">,</span> <span class="n">all</span><span class="nf">.len</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Third case: we expect to see <code>n * (n - 1) / 2</code> unordered pairs of numbers.
This one is interesting&#8201;&#8212;&#8201;here, our second decision is based on the first one, but we still enumerate all the cases efficiently (without duplicates).
(Aside: did you ever realise that the number of ways to pick two objects out of <code>n</code> is equal to the sum of first <code>n</code> natural numbers?)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">gen_number_combination</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">expected_total</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

  <span class="k">let</span> <span class="k">mut</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">all</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">g</span> <span class="o">=</span> <span class="nn">Gen</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
  <span class="k">while</span> <span class="o">!</span><span class="n">g</span><span class="nf">.done</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="n">g</span><span class="nf">.gen</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">g</span><span class="nf">.gen</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">all</span><span class="nf">.insert</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">));</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">expected_total</span><span class="p">,</span> <span class="n">total</span><span class="p">);</span>
  <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">expected_total</span><span class="p">,</span> <span class="n">all</span><span class="nf">.len</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;ve already generated all arrays, so let&#8217;s try to create all permutations.
Still efficient:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">gen_permutations</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">expected_total</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..=</span><span class="n">n</span><span class="p">)</span><span class="py">.product</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="k">let</span> <span class="k">mut</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">all</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">g</span> <span class="o">=</span> <span class="nn">Gen</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
  <span class="k">while</span> <span class="o">!</span><span class="n">g</span><span class="nf">.done</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">candidates</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..=</span><span class="n">n</span><span class="p">)</span><span class="nf">.collect</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">permutation</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">for</span> <span class="mi">_</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">n</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">g</span><span class="nf">.gen</span><span class="p">(</span><span class="n">candidates</span><span class="nf">.len</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u32</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
      <span class="n">permutation</span><span class="nf">.push</span><span class="p">(</span><span class="n">candidates</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">all</span><span class="nf">.insert</span><span class="p">(</span><span class="n">permutation</span><span class="p">);</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">expected_total</span><span class="p">,</span> <span class="n">total</span><span class="p">);</span>
  <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">expected_total</span><span class="p">,</span> <span class="n">all</span><span class="nf">.len</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Subsets:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">gen_subset</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">expected_total</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">all</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">g</span> <span class="o">=</span> <span class="nn">Gen</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">while</span> <span class="o">!</span><span class="n">g</span><span class="nf">.done</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">s</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="mi">_</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">n</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="mi">_</span><span class="p">|</span> <span class="n">g</span><span class="nf">.gen</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.collect</span><span class="p">();</span>

        <span class="n">all</span><span class="nf">.insert</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">expected_total</span><span class="p">,</span> <span class="n">total</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">expected_total</span><span class="p">,</span> <span class="n">all</span><span class="nf">.len</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Combinations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">gen_combinations</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">fact</span> <span class="o">=</span> <span class="p">|</span><span class="n">n</span><span class="p">:</span> <span class="nb">u32</span><span class="p">|</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span> <span class="p">(</span><span class="mi">1</span><span class="o">..=</span><span class="n">n</span><span class="p">)</span><span class="nf">.product</span><span class="p">()</span> <span class="p">};</span>
    <span class="k">let</span> <span class="n">expected_total</span> <span class="o">=</span> <span class="nf">fact</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nf">fact</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">*</span> <span class="nf">fact</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">m</span><span class="p">));</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">all</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">g</span> <span class="o">=</span> <span class="nn">Gen</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">while</span> <span class="o">!</span><span class="n">g</span><span class="nf">.done</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">candidates</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..=</span><span class="n">n</span><span class="p">)</span><span class="nf">.collect</span><span class="p">();</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">combination</span> <span class="o">=</span> <span class="nn">BTreeSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">for</span> <span class="mi">_</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">m</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">g</span><span class="nf">.gen</span><span class="p">(</span><span class="n">candidates</span><span class="nf">.len</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u32</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">combination</span><span class="nf">.insert</span><span class="p">(</span><span class="n">candidates</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="n">all</span><span class="nf">.insert</span><span class="p">(</span><span class="n">combination</span><span class="p">);</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">expected_total</span><span class="p">,</span> <span class="n">total</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">expected_total</span><span class="p">,</span> <span class="n">all</span><span class="nf">.len</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, this one actually fails&#8201;&#8212;&#8201;while this code generates all combinations, some combinations are generated more than once.
Specifically, what we are generating here are k-permutations (combinations with significant order of elements).
While this is not efficient, this is OK for the purposes of exhaustive testing (as we still generate any combination).
Nonetheless, there&#8217;s an efficient version as well:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
</pre></td><td class="code"><pre><span class="k">let</span> <span class="k">mut</span> <span class="n">combination</span> <span class="o">=</span> <span class="nn">BTreeSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
<span class="k">for</span> <span class="n">c</span> <span class="n">in</span> <span class="mi">1</span><span class="o">..=</span><span class="n">n</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">combination</span><span class="nf">.len</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u32</span> <span class="o">==</span> <span class="n">m</span> <span class="p">{</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="n">combination</span><span class="nf">.len</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u32</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">m</span> <span class="p">{</span>
    <span class="n">combination</span><span class="nf">.extend</span><span class="p">(</span><span class="n">c</span><span class="o">..=</span><span class="n">n</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="n">g</span><span class="nf">.gen</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
    <span class="n">combination</span><span class="nf">.insert</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>I think this covers all standard combinatorial structures.
What&#8217;s interesting, this approach works for non-standard structures as well.
For example, for <a href="https://cses.fi/problemset/task/2168" class="bare">https://cses.fi/problemset/task/2168</a>, the problem which started all this, I need to generate sequences of segments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">gen_segments</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>

  <span class="k">let</span> <span class="k">mut</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">all</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">g</span> <span class="o">=</span> <span class="nn">Gen</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
  <span class="k">while</span> <span class="o">!</span><span class="n">g</span><span class="nf">.done</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="n">g</span><span class="nf">.gen</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">xs</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">for</span> <span class="mi">_</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">l</span> <span class="p">{</span>
      <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="n">g</span><span class="nf">.gen</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">g</span><span class="nf">.gen</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">if</span> <span class="o">!</span><span class="n">xs</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span> <span class="p">{</span>
          <span class="n">xs</span><span class="nf">.push</span><span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">all</span><span class="nf">.insert</span><span class="p">(</span><span class="n">xs</span><span class="p">);</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">all</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">2_593_942</span><span class="p">);</span>
  <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="mi">4_288_306</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Due to the <code>.contains</code> check there are some duplicates, but that&#8217;s not a problem as long as all sequences of segments are generated.
Additionally, examples are strictly ordered by their complexity&#8201;&#8212;&#8201;earlier examples have fewer segments with smaller coordinates.
That means that the first example which fails a property test is actually guaranteed to be the smallest counterexample! Nifty!</p>
</div>
<div class="paragraph">
<p>That&#8217;s all!
Next time when you need to test something, consider if you can just exhaustively enumerate all &#8220;sufficiently small&#8221; inputs.
If that&#8217;s feasible, you can either write the classical recursive enumerator, or use this imperative <code>Gen</code> thing.</p>
</div>
<div class="paragraph">
<p><strong>Update(2021-11-28):</strong></p>
</div>
<div class="paragraph">
<p>There are now Rust (<a href="https://crates.io/crates/exhaustigen">crates.io link</a>) and C&#43;&#43; (<a href="https://github.com/graydon/exhaustigen">GitHub link</a>) implementations.
<a href="https://arxiv.org/abs/1710.10385">&#8220;Capturing the Future by Replaying the Past&#8221;</a> is a related paper which includes the above technique as a special case of &#8220;simulate any monad by simulating delimited continuations via exceptions and replay&#8221; trick.</p>
</div>
<div class="paragraph">
<p>Balanced parentheses sequences:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">gen_parenthesis</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">expected_total</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">14</span> <span class="o">+</span> <span class="mi">42</span><span class="p">;</span>

  <span class="k">let</span> <span class="k">mut</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">all</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
  <span class="k">let</span> <span class="k">mut</span> <span class="n">g</span> <span class="o">=</span> <span class="nn">Gen</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
  <span class="k">while</span> <span class="o">!</span><span class="n">g</span><span class="nf">.done</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="n">g</span><span class="nf">.gen</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">bra</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">ket</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="n">ket</span> <span class="o">&lt;</span> <span class="n">l</span> <span class="p">{</span>
      <span class="k">if</span> <span class="n">bra</span> <span class="o">&lt;</span> <span class="n">l</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bra</span> <span class="o">==</span> <span class="n">ket</span> <span class="p">||</span> <span class="n">g</span><span class="nf">.gen</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">s</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'('</span><span class="p">);</span>
        <span class="n">bra</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">s</span><span class="nf">.push</span><span class="p">(</span><span class="sc">')'</span><span class="p">);</span>
        <span class="n">ket</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">all</span><span class="nf">.insert</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">expected_total</span><span class="p">,</span> <span class="n">total</span><span class="p">);</span>
  <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">expected_total</span><span class="p">,</span> <span class="n">all</span><span class="nf">.len</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</article>

  </main>

  <footer class="site-footer">
    <p>
      <a href="https://github.com/matklad/matklad.github.io/edit/master/_posts/2021-11-07-generate-all-the-things.adoc">
        <i class="fa fa-edit"></i> fix typo
      </a>

      <a href=" /feed.xml">
        <i class="fa fa-rss"></i> rss
      </a>

      <a href="https://github.com/matklad">
        <i class="fa fa-github"></i> matklad
      </a>
    </p>
  </footer>
</body>

</html>
